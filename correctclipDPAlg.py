from intervaltree import Interval, IntervalTree
import sys
import numpy as np


"""
A class representing a physical operator tree
"""
class PhysOpTree:
    """
    op_str: A string representing the operation to be performed
    res_int: the expected result interval
    children: a list of PhysOpTree objects containing the intervals to be
    operated on to get res_int
    """
    def __init__(self, op_str, res_int, children):
        self.op_str = op_str
        self.res_int = res_int
        self.children = children
        
    def printToString(self):
        prStr = "{" + self.op_str + "," + str(self.res_int) + " "
        for c in self.children:
            prStr += c.printToString()
        prStr += "}"
        return prStr
    

#compute cost of merging i1 with i2
def est_Single(i1, i2):
    base_ccost = 10
    merge_cost = 20
    if isIn(i1,i2): #if i1 is contained in i2
        print("Why are you comparing")
        print(i1)
        print("to")
        print(i2)
        return -1 #the cost is just 0, because we replace i1 by i2
    if isIn(i2,i1): #if i2 is contained in i1
        print("Why are you comparing")
        print(i1)
        print("to")
        print(i2)
        return -1 #the cost is just 0, because we replace i2 by i1
    if i1.begin - i2.end < 0 and i1.end - i2.end > 0:
        crop_cost = abs(i1.begin - i2.end) * base_ccost
    elif i2.begin - i1.end < 0 and i2.end - i1.end > 0:
        crop_cost = abs(i2.begin - i1.end) * base_ccost
    else:
        crop_cost = 0
    tot_cost = merge_cost + crop_cost
    return tot_cost

#check if i1 is contained in i2
def isIn(i1,i2):
    return i1.begin >= i2.begin and i1.end <= i2.end

#compute cost of cropping i1 into i2
def crop_Cost(i1,i2):
    if isIn(i2,i1):
        base_ccost = 10
        return (i2.begin - i1.begin + i1.end - i2.end)*base_ccost
    return -1

#insert the clips into an interval tree
#and then find all intervals overlapping with the given one
def clips_in_range(clips, i1):
    """
    clips: a list of pairs representing intervals
    Later on, we'll want to replace this with the actual header + clip file
    structure, and create the intervals first.
    """
    t = IntervalTree(Interval(begin, end, "%d-%d" % (begin, end)) for begin, end in clips)
    tset = t.overlap(i1[0],i1[1])
    tlst = sorted(list(tset), key=lambda x: x.begin, reverse=True)
    return tlst

#given a list of clips, a matrix describing the optimal break point for
#every interval within the target interval, and the target interval itself,
#return the list of clips to be merged to create the target interval.
#def construct_Sol(clst, H, bg, targInt,reslst=[]):
#    target = (targInt.begin, targInt.end)
#    if target in H:
#        isM,ind = H[target]
#        if isM:
#            t1 = Interval(targInt.begin, ind, (targInt.begin, ind))
#            t2 = Interval(ind, targInt.end, (ind, targInt.end))
#            if t1.begin == target[0] and t1.end == target[1]:
#                """
#                there must be some mistake, because a length 2 interval cannot
#                be constructed by merging any other intervals at all. The only way to
#                construct such an interval is by cropping down an interval that
#                contains it
#                """
#                raise Exception("ERROR: length-2 interval cannot be generated by merging: " + str(t1.begin) + "," + str(t1.end))
#            reslst += construct_Sol(clst, H, bg, t1, reslst)
#            reslst += construct_Sol(clst, H, bg, t2, reslst)
#            return reslst
#        else:
#            reslst.append(clst[ind])
#            return reslst
#    else:
#        print(H)
#        raise Exception("ERROR: all intervals should be present in hashmap: " + str(targInt.begin) + "," + str(targInt.end))
    
def construct_Sol(clst, H, bg, targInt):
    target = (targInt.begin, targInt.end)
    if target in H:
        isM, ind = H[target]
        if not isM:
            """
            Base case: if the target interval is equal to the interval given by
            the index, then we're done
            """
            cInt = clst[ind]
            if cInt.begin == target[0] + bg and cInt.end == target[1] + bg:
                return PhysOpTree("retrieve", [cInt.begin, cInt.end], [])
            else:
                childlst = []
                newst = cInt.begin - bg
                newend = cInt.end - bg
                newInt = Interval(newst, newend, (newst,newend))
                childlst.append(construct_Sol(clst, H, bg, newInt))
                return PhysOpTree("crop", [bg + target[0], bg + target[1]], childlst)
        else:
            t1 = Interval(targInt.begin, ind, (targInt.begin, ind))
            t2 = Interval(ind, targInt.end, (ind, targInt.end))
            if t1.begin == target[0] and t1.end == target[1]:
                """
                there must be some mistake, because a length 2 interval cannot
                be constructed by merging any other intervals at all. The only way to
                construct such an interval is by cropping down an interval that
                contains it
                """
                raise Exception("ERROR: length-2 interval cannot be generated by merging: " + str(t1.begin) + "," + str(t1.end))
            childlst = []
            childlst.append(construct_Sol(clst,H,bg,t1))
            childlst.append(construct_Sol(clst,H,bg,t2))
            actualTInt = [targInt.begin + bg, targInt.end + bg]
            return PhysOpTree("merge", actualTInt, childlst)
    else:
        raise Exception("ERROR: all intervals should be present in hashmap: " + str(targInt.begin) + "," + str(targInt.end))
            

def dp_alg(clst, target):
    tlen = target[1] - target[0] + 1
    memo = np.full((tlen,tlen), sys.maxsize)
    H = {}
    targInt = Interval(target[0], target[1], target)
    #if the target is contained in clst, just return the clip; cost 0
    #or if the clip is contained in one of the clips in clst, return the
    #minimum-cost clip that contains it, along with the cost.
#    cov = [x for x in clst if isIn(targInt,x)]
#    if cov:
#        min_cost = sys.maxsize
#        min_int = None
#        for c in cov:
#            cost = crop_Cost(c,target)
#            if cost < min_cost:
#                min_cost = cost
#                min_int = c
#        return (min_cost, [min_int])
        
    for l in range(2,tlen+1): #l actually represents the length of the interval
        for i in range(tlen-l+1):
            j = i + l - 1
            st = targInt.begin + i
            end = targInt.begin + j
            #if the interval is already in the list, the cost is 0
            ints = [(n,x) for n,x in enumerate(clst) if x.begin == st and x.end == end]
            if ints:
                memo[i][j] = 0
                H[(i,j)] = (False, ints[0][0])
                continue
            #compare the min cost of cropping, vs min cost of constructing
            #interval from clip--simple            
            ijInt = Interval(st, end, (st,end))
            memo[i][j] = sys.maxsize
            cov = [x for x in clst if isIn(ijInt,x)]
            if cov:
                if i == 0 and j == 1:
                    print(cov)
                min_ccost = sys.maxsize
                min_int = -1
                for m,c in enumerate(clst):
                    cost = crop_Cost(c, ijInt)
                    if cost != -1 and cost < min_ccost:
                        min_ccost = cost
                        min_int = m
                if i == 0 and j == 1:
                    print("Cost of 0,1: " + str(min_ccost))
                    print("index for 0,1: " + str(min_int))
                #This doesn't work, because we need the indices of the clst
#                cclst = list(map(lambda x,y: crop_Cost(x,y), cov, [ijInt]*len(cov)))
#                min_ccost = min(cclst)
#                min_int = cclst.index(min_ccost)
                memo[i][j] = min_ccost
                H[(i,j)] = (False,min_int) #note: this represents the index
                #to the clip to crop in the original list! NOT the breaking
                #point for an interval. We will need to account for the
                #difference in meaning when we go back and reconstruct the
                #result list
            for k in range(i,j-1):
                kpt = targInt.begin + k
                t1 = Interval(st,kpt+1,(st,kpt+1))
                t2 = Interval(kpt+1,end,(kpt+1,end))
                if memo[i][k+1] == sys.maxsize:
                    raise Exception("ERROR: Not supposed to use entry: " + str(i) + "," + str(k+1))
                if memo[k+1][j] == sys.maxsize:
                    raise Exception("ERROR: Not supposed to use entry: " + str(k+1) + "," + str(j))
                q = memo[i][k+1] + memo[k+1][j] + est_Single(t1,t2)
                if q < memo[i][j]:
                    memo[i][j] = q
                    H[(i,j)] = (True, k+1) #this represents the optimal breaking
                    #point, not the position in the clip to be cropped.
    print(memo)
    print(H)
    reslst = construct_Sol(clst,H,targInt.begin, Interval(0, targInt.end - targInt.begin, (0, targInt.end - targInt.begin)))
    return (memo[0, target[1]-target[0]],reslst)

#ivs = [(1,3),(2,5),(3,4),(4,5)]
#ivs = [(0,3),(3,8),(8,11),(11,15),(15,18),(18,20),(2,5),(5,7),(7,17),(14,17),(17,20)]
ivs = [(0,3),(3,7),(7,11),(11,15),(15,18),(18,20),(0,5),(5,7),(7,10),(10,14),(14,17),(17,20)]
#i1 = [1,5]
i1 = [3,17]
ivsObjs = clips_in_range(ivs,i1)
print("ivsObjs:")
print(ivsObjs)
cst,tr = dp_alg(ivsObjs,i1)
print("Minimum Cost: " + str(cst))
print("Minimum Cost Tree:")
trstr = tr.printToString()
print(trstr)
                        
                
                    